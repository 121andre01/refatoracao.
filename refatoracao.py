# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YShQXjPxxPHAix1ycZqu9G4HrNIM3gDp
"""

from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, NoAlertPresentException
from datetime import datetime
from typing import Optional, Dict, Any, List
import time
import pandas as pd
import json



class BasePage:
    """Classe base para todas as páginas com funcionalidades comuns."""

    def __init__(self, driver: webdriver.Chrome):
        self.driver = driver
        self.wait = WebDriverWait(driver, 10)
        self.base_url = "https://demoblaze.com/"

    def open_page(self, url: str = None):
        """Abre uma página específica ou a página base."""
        target_url = url if url else self.base_url
        self.driver.get(target_url)

    def find_element(self, locator: tuple, timeout: int = 10):
        """Encontra um elemento com wait implícito."""
        wait = WebDriverWait(self.driver, timeout)
        return wait.until(EC.presence_of_element_located(locator))

    def find_clickable_element(self, locator: tuple, timeout: int = 10):
        """Encontra um elemento clicável com wait implícito."""
        wait = WebDriverWait(self.driver, timeout)
        return wait.until(EC.element_to_be_clickable(locator))

    def wait_for_alert(self, timeout: int = 5) -> Optional[str]:
        """Aguarda por um alert e retorna seu texto."""
        try:
            alert = WebDriverWait(self.driver, timeout).until(EC.alert_is_present())
            text = alert.text
            alert.accept()
            time.sleep(2)
            return text
        except TimeoutException:
            return None

    def clear_and_send_keys(self, locator: tuple, text: str):
        """Limpa um campo e insere texto."""
        element = self.find_element(locator)
        element.clear()
        if text:
            element.send_keys(text)




class HomePage(BasePage):
    """Página inicial do Demoblaze com navegação principal."""

    # Locators
    NAVBAR = (By.ID, "nava")
    SIGN_UP_BUTTON = (By.ID, "signin2")
    LOGIN_BUTTON = (By.ID, "login2")
    WELCOME_USER = (By.ID, "nameofuser")
    LOGOUT_BUTTON = (By.ID, "logout2")

    def __init__(self, driver: webdriver.Chrome):
        super().__init__(driver)

    def open_home_page(self):
        """Abre a página inicial e aguarda carregamento."""
        self.open_page()
        self.wait_for_page_load()

    def wait_for_page_load(self):
        """Aguarda o carregamento completo da página."""
        self.find_element(self.NAVBAR, timeout=15)
        time.sleep(2)

    def click_sign_up(self):
        """Clica no botão de cadastro."""
        sign_up_btn = self.find_clickable_element(self.SIGN_UP_BUTTON)
        sign_up_btn.click()
        time.sleep(2)

    def click_login(self):
        """Clica no botão de login."""
        login_btn = self.find_clickable_element(self.LOGIN_BUTTON)
        login_btn.click()
        time.sleep(2)

    def is_user_logged_in(self) -> bool:
        """Verifica se usuário está logado."""
        try:
            self.find_element(self.WELCOME_USER, timeout=5)
            return True
        except TimeoutException:
            return False

    def get_welcome_message(self) -> Optional[str]:
        """Obtém mensagem de boas-vindas do usuário logado."""
        try:
            welcome_element = self.find_element(self.WELCOME_USER, timeout=5)
            return welcome_element.text
        except TimeoutException:
            return None




class SignUpPage(BasePage):
    """Página de cadastro de usuários."""


    MODAL = (By.ID, "signInModal")
    USERNAME_INPUT = (By.ID, "sign-username")
    PASSWORD_INPUT = (By.ID, "sign-password")
    SIGN_UP_BUTTON = (By.XPATH, "//button[contains(@class,'btn') and contains(text(),'Sign up')]")
    CLOSE_BUTTON = (By.XPATH, "//button[@class='btn btn-secondary' and @data-dismiss='modal']")

    def __init__(self, driver: webdriver.Chrome):
        super().__init__(driver)

    def wait_for_modal(self):
        """Aguarda o modal de cadastro aparecer."""
        self.find_element(self.MODAL)
        time.sleep(1)

    def fill_username(self, username: str):
        """Preenche o campo de usuário."""
        self.clear_and_send_keys(self.USERNAME_INPUT, username)

    def fill_password(self, password: str):
        """Preenche o campo de senha."""
        self.clear_and_send_keys(self.PASSWORD_INPUT, password)

    def click_sign_up_button(self):
        """Clica no botão de confirmar cadastro."""
        btn = self.find_clickable_element(self.SIGN_UP_BUTTON)
        btn.click()
        time.sleep(3)

    def perform_sign_up(self, username: str, password: str) -> str:
        """Executa o processo completo de cadastro."""
        self.wait_for_modal()
        self.fill_username(username)
        self.fill_password(password)
        self.click_sign_up_button()


        alert_text = self.wait_for_alert()
        return alert_text if alert_text else "Nenhum alert encontrado"




class LoginPage(BasePage):
    """Página de login de usuários."""

    # Locators
    MODAL = (By.ID, "logInModal")
    USERNAME_INPUT = (By.ID, "loginusername")
    PASSWORD_INPUT = (By.ID, "loginpassword")
    LOGIN_BUTTON = (By.XPATH, "//button[contains(@class,'btn') and contains(text(),'Log in')]")
    CLOSE_BUTTON = (By.XPATH, "//button[@class='btn btn-secondary' and @data-dismiss='modal']")

    def __init__(self, driver: webdriver.Chrome):
        super().__init__(driver)

    def wait_for_modal(self):
        """Aguarda o modal de login aparecer."""
        self.find_element(self.MODAL)
        time.sleep(1)

    def fill_username(self, username: str):
        """Preenche o campo de usuário."""
        self.clear_and_send_keys(self.USERNAME_INPUT, username)

    def fill_password(self, password: str):
        """Preenche o campo de senha."""
        self.clear_and_send_keys(self.PASSWORD_INPUT, password)

    def click_login_button(self):
        """Clica no botão de login."""
        btn = self.find_clickable_element(self.LOGIN_BUTTON)
        btn.click()
        time.sleep(3)

    def perform_login(self, username: str, password: str) -> str:
        """Executa o processo completo de login."""
        self.wait_for_modal()
        self.fill_username(username)
        self.fill_password(password)
        self.click_login_button()


        home_page = HomePage(self.driver)
        if home_page.is_user_logged_in():
            return "login_success"


        alert_text = self.wait_for_alert()
        return alert_text if alert_text else "Nenhum alert encontrado"



class DriverFactory:
    """Factory para criação e configuração do WebDriver."""

    @staticmethod
    def create_chrome_driver(headless: bool = True) -> Optional[webdriver.Chrome]:
        """Cria instância do Chrome Driver otimizada para Colab."""
        try:
            chrome_options = Options()

            if headless:
                chrome_options.add_argument("--headless")


            chrome_options.add_argument("--no-sandbox")
            chrome_options.add_argument("--disable-dev-shm-usage")
            chrome_options.add_argument("--disable-gpu")
            chrome_options.add_argument("--window-size=1920,1080")
            chrome_options.add_argument("--disable-web-security")
            chrome_options.add_argument("--allow-running-insecure-content")
            chrome_options.add_argument("--disable-extensions")
            chrome_options.add_argument("--disable-plugins")
            chrome_options.add_argument("--disable-images")
            chrome_options.add_experimental_option("excludeSwitches", ["enable-automation"])
            chrome_options.add_experimental_option('useAutomationExtension', False)

            driver = webdriver.Chrome(options=chrome_options)
            return driver

        except Exception as e:
            print(f"❌ Erro ao criar driver: {e}")
            return None



class TestDataManager:
    """Gerenciador de dados de teste e cenários."""

    @staticmethod
    def get_test_scenarios() -> Dict[str, Dict[str, Any]]:
        """Retorna os cenários de teste definidos."""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")

        return {
            'cenario_1': {
                'nome': 'Cadastro com Username e Password válidos',
                'tipo': 'signup',
                'username': f'Usuario_Valido_{timestamp}',
                'password': 'testeSenai1234',
                'esperado': 'Sign up successful.',
                'descricao': 'Testa cadastro com credenciais válidas'
            },
            'cenario_2': {
                'nome': 'Cadastro com Username já existente',
                'tipo': 'signup',
                'username': 'LorranyMarimSenai',
                'password': 'testeSenai1234',
                'esperado': 'This user already exist.',
                'descricao': 'Testa cadastro com usuário duplicado'
            },
            'cenario_3': {
                'nome': 'Cadastro com campos vazios',
                'tipo': 'signup',
                'username': '',
                'password': '',
                'esperado': 'Please fill out Username and Password.',
                'descricao': 'Testa validação de campos obrigatórios'
            },
            'cenario_4': {
                'nome': 'Cadastro com senha muito curta',
                'tipo': 'signup',
                'username': f'Usuario_Senha_Curta_{timestamp}',
                'password': '123',
                'esperado': 'Sign up successful.',
                'descricao': 'Testa aceitação de senhas curtas'
            },
            'cenario_5': {
                'nome': 'Cadastro com caracteres especiais',
                'tipo': 'signup',
                'username': f'User@#$_{timestamp}',
                'password': 'Senha@123!',
                'esperado': 'Sign up successful.',
                'descricao': 'Testa cadastro com caracteres especiais'
            },
            'cenario_6': {
                'nome': 'Login com credenciais válidas',
                'tipo': 'login',
                'username': 'LorranyMarimSenai',
                'password': 'testeSenai1234',
                'esperado': 'login_success',
                'descricao': 'Testa login com credenciais corretas'
            },
            'cenario_7': {
                'nome': 'Login com username inválido',
                'tipo': 'login',
                'username': 'UsuarioInexistente123',
                'password': 'testeSenai1234',
                'esperado': 'User does not exist.',
                'descricao': 'Testa login com usuário inexistente'
            },
            'cenario_8': {
                'nome': 'Login com senha incorreta',
                'tipo': 'login',
                'username': 'LorranyMarimSenai',
                'password': 'senhaErrada123',
                'esperado': 'Wrong password.',
                'descricao': 'Testa login com senha incorreta'
            },
            'cenario_9': {
                'nome': 'Login com campos vazios',
                'tipo': 'login',
                'username': '',
                'password': '',
                'esperado': 'Please fill out Username and Password.',
                'descricao': 'Testa validação de campos obrigatórios no login'
            },
            'cenario_10': {
                'nome': 'Cadastro com username muito longo',
                'tipo': 'signup',
                'username': f'Usuario_Com_Nome_Muito_Longo_Para_Teste_{timestamp}_' + 'x' * 50,
                'password': 'testeSenai1234',
                'esperado': 'Sign up successful.',
                'descricao': 'Testa cadastro com username extenso'
            }
        }




class TestExecutor:
    """Executor principal dos testes usando Page Object Model."""

    def __init__(self):
        self.driver: Optional[webdriver.Chrome] = None
        self.results: Dict[str, Any] = {}
        self.scenarios = TestDataManager.get_test_scenarios()

    def setup(self) -> bool:
        """Configura o ambiente de teste."""
        print("🚗 Inicializando Chrome Driver...")
        self.driver = DriverFactory.create_chrome_driver(headless=True)

        if self.driver:
            print("✅ Chrome Driver inicializado com sucesso!")
            return True
        else:
            print("❌ Falha ao inicializar driver")
            return False

    def teardown(self):
        """Finaliza o ambiente de teste."""
        if self.driver:
            self.driver.quit()
            print("🔌 Driver finalizado")

    def execute_scenario(self, scenario_id: str) -> Dict[str, Any]:
        """Executa um cenário específico usando Page Objects."""
        if scenario_id not in self.scenarios:
            return {"erro": f"Cenário {scenario_id} não encontrado"}

        scenario = self.scenarios[scenario_id]
        start_time = datetime.now()

        print(f"\n{'='*60}")
        print(f"🧪 EXECUTANDO: {scenario['nome']}")
        print(f"{'='*60}")
        print(f"Tipo: {scenario['tipo'].upper()}")
        print(f"Username: {scenario['username']}")
        print(f"Password: {'*' * len(scenario['password']) if scenario['password'] else 'Vazio'}")
        print(f"Esperado: {scenario['esperado']}")

        try:

            home_page = HomePage(self.driver)


            home_page.open_home_page()


            if scenario['tipo'] == 'signup':
                home_page.click_sign_up()
                signup_page = SignUpPage(self.driver)
                actual_result = signup_page.perform_sign_up(
                    scenario['username'],
                    scenario['password']
                )
            elif scenario['tipo'] == 'login':
                home_page.click_login()
                login_page = LoginPage(self.driver)
                actual_result = login_page.perform_login(
                    scenario['username'],
                    scenario['password']
                )
            else:
                raise Exception(f"Tipo de cenário desconhecido: {scenario['tipo']}")


            success = actual_result == scenario['esperado']
            end_time = datetime.now()
            duration = (end_time - start_time).total_seconds()

            result = {
                'cenario_id': scenario_id,
                'nome': scenario['nome'],
                'tipo': scenario['tipo'],
                'username': scenario['username'],
                'password_length': len(scenario['password']) if scenario['password'] else 0,
                'esperado': scenario['esperado'],
                'obtido': actual_result,
                'sucesso': success,
                'duracao_segundos': round(duration, 2),
                'timestamp': start_time.strftime('%Y-%m-%d %H:%M:%S'),
                'status': '✅ PASSOU' if success else '❌ FALHOU'
            }

            print(f"Resultado: {actual_result}")
            print(f"Status: {result['status']}")
            print(f"Duração: {duration:.2f}s")

            return result

        except Exception as e:
            end_time = datetime.now()
            duration = (end_time - start_time).total_seconds()

            result = {
                'cenario_id': scenario_id,
                'nome': scenario['nome'],
                'tipo': scenario['tipo'],
                'username': scenario['username'],
                'password_length': len(scenario['password']) if scenario['password'] else 0,
                'esperado': scenario['esperado'],
                'obtido': f"ERRO: {str(e)}",
                'sucesso': False,
                'duracao_segundos': round(duration, 2),
                'timestamp': start_time.strftime('%Y-%m-%d %H:%M:%S'),
                'status': '💥 ERRO'
            }

            print(f"❌ ERRO: {str(e)}")
            return result

    def execute_all_scenarios(self):
        """Executa todos os cenários de teste."""
        print("🚀 INICIANDO AUTOMAÇÃO COMPLETA - DEMOBLAZE (Page Object Model)")
        print(f"⏰ Início: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print("🌐 Ambiente: Google Colab")

        if not self.setup():
            return

        try:
            for i, scenario_id in enumerate(self.scenarios.keys(), 1):
                print(f"\n🔄 Progresso: {i}/10 cenários")
                result = self.execute_scenario(scenario_id)
                self.results[scenario_id] = result
                time.sleep(1)

        finally:
            self.teardown()

        print(f"\n🏁 AUTOMAÇÃO CONCLUÍDA!")
        print(f"⏰ Fim: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")

        self.generate_reports()
        self.display_summary()

    def generate_reports(self):
        """Gera relatórios dos testes."""
        if not self.results:
            print("❌ Nenhum resultado para gerar relatório")
            return


        df = pd.DataFrame(list(self.results.values()))


        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        csv_file = f"demoblaze_pom_relatorio_{timestamp}.csv"
        json_file = f"demoblaze_pom_relatorio_{timestamp}.json"


        df.to_csv(csv_file, index=False, encoding='utf-8')


        with open(json_file, 'w', encoding='utf-8') as f:
            json.dump(self.results, f, indent=2, ensure_ascii=False)

        print(f"\n📊 RELATÓRIOS GERADOS:")
        print(f"   📄 {csv_file}")
        print(f"   📄 {json_file}")

        print(f"\n📋 PREVIEW DOS RESULTADOS:")
        print(df[['nome', 'status', 'duracao_segundos']].to_string(index=False))

        return df

    def display_summary(self):
        """Exibe resumo executivo dos testes."""
        if not self.results:
            return

        total = len(self.results)
        successes = sum(1 for r in self.results.values() if r['sucesso'])
        failures = total - successes

        total_time = sum(r['duracao_segundos'] for r in self.results.values())
        avg_time = total_time / total if total > 0 else 0
        success_rate = (successes / total) * 100 if total > 0 else 0

        print(f"\n🎯 RESUMO EXECUTIVO:")
        print(f"   ✅ Total de cenários: {total}")
        print(f"   🟢 Sucessos: {successes}")
        print(f"   🔴 Falhas: {failures}")
        print(f"   📊 Taxa de sucesso: {success_rate:.1f}%")
        print(f"   ⏱️  Tempo total: {total_time:.2f}s")
        print(f"   ⏱️  Tempo médio: {avg_time:.2f}s")

        failed_scenarios = [r for r in self.results.values() if not r['sucesso']]
        if failed_scenarios:
            print(f"\n🔍 CENÁRIOS QUE FALHARAM:")
            for failure in failed_scenarios:
                print(f"   ❌ {failure['nome']}")
                print(f"      Esperado: {failure['esperado']}")
                print(f"      Obtido: {failure['obtido']}")




def executar_automacao_pom():
    """Função principal para executar a automação com Page Object Model."""
    try:
        print("🎭 INICIANDO AUTOMAÇÃO DEMOBLAZE COM PAGE OBJECT MODEL")
        print("=" * 60)


        executor = TestExecutor()


        executor.execute_all_scenarios()

        print("\n" + "=" * 60)
        print("🎉 AUTOMAÇÃO COM POM CONCLUÍDA COM SUCESSO!")
        print("📁 Arquivos de relatório salvos no ambiente Colab")
        print("💾 Use os comandos abaixo para baixar os arquivos:")
        print("   from google.colab import files")
        print("   files.download('demoblaze_pom_relatorio_TIMESTAMP.csv')")
        print("=" * 60)

        return executor.results

    except Exception as e:
        print(f"❌ Erro na execução: {e}")
        return None




if __name__ == "__main__":

    resultados = executar_automacao_pom()
else:
    print("✅ Módulo Page Object Model carregado!")
    print("Execute executar_automacao_pom() para iniciar os testes.")